#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier:enable
#extension GL_GOOGLE_include_directive : enable

#include "gi_raytrace.h"

layout(location = 0) rayPayloadEXT IndirectRayPayload indirectRpl;
layout(location = 1) rayPayloadEXT AORayPayload aoRpl;

layout(set = 0, binding = 1) uniform sampler2D texSet[];
layout(set = 0, binding = 2) uniform accelerationStructureEXT topLevelAS;

layout(set = 1, binding = 0) uniform _GlobalGIParams { SGlobalGIParams giParams; };

layout(set = 1, binding = 1) readonly buffer _Lights{

	SLight lights[];
} lightsBuffer;

layout(set = 1, binding = 2) readonly buffer ObjectBuffer{

	SObjectData objects[];
} objectBuffer;

layout(set = 2, binding = 0) uniform sampler2D indirectInput;
layout(set = 2, binding = 1) uniform sampler2D reservoirSpatial;
layout(set = 2, binding = 2, rgba32f) uniform image2D reservoirPrev;
layout(set = 2, binding = 3, rgba32f) uniform image2D outputTex;

layout(set = 3, binding = 0) uniform sampler2D wposTex;
layout(set = 3, binding = 1) uniform sampler2D normalTex;
layout(set = 3, binding = 2) uniform sampler2D uvTex;
layout(set = 3, binding = 3) uniform sampler2D objIDTex;
layout(set = 3, binding = 4) uniform samplerCube irradianceMap;
layout(set = 3, binding = 5) uniform samplerCube prefilteredMap;
layout(set = 3, binding = 6) uniform sampler2D   brdfLUT;


#include "gi_raytrace_func.h"

void main() 
{
    const vec2 uv = vec2(gl_LaunchIDEXT.xy)/vec2(gl_LaunchSizeEXT.xy);
    vec4 worldPos = texture(wposTex, uv).rgba;
    vec3 worldNorm = normalize(texture(normalTex, uv).rgb);

    vec4 reservoir =  texture(reservoirSpatial, ivec2(gl_LaunchIDEXT.xy)).rgba;
	imageStore(reservoirPrev, ivec2(gl_LaunchIDEXT.xy), reservoir);

	vec4 indirectColor = texture(indirectInput, ivec2(gl_LaunchIDEXT.xy)).rgba;

    if (worldPos.w != 0.0f)
	{
        float objIDf = texture(objIDTex, uv).r;
        vec2 gbufferTexCoord = texture(uvTex, uv).rg;

        DirectInputData inputData = packDirectInputData(objIDf, worldPos.xyz, worldNorm, gbufferTexCoord);

        uint lightToSample = uint(reservoir.y);
        DirectOutputData outputCurrentData = ggxDirect(lightToSample, inputData, giParams.camPos.xyz, true);
        indirectColor += vec4(float(giParams.lightsCount) * unpackLo_DirectOutputData(outputCurrentData) * reservoir.w, 1.f);
	}

	imageStore(outputTex, ivec2(gl_LaunchIDEXT.xy), indirectColor);
}
