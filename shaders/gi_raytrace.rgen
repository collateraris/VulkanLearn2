#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable

#include "gi_raytrace.h"

layout(location = 0) rayPayloadEXT AORayPayload aoRpl;
layout(location = 1) rayPayloadEXT ShadowRayPayload shadowRpl;
layout(location = 2) rayPayloadEXT IndirectRayPayload indirectRpl;

layout(set = 1, binding = 0) uniform _GlobalAOParams { SGlobalAOParams aoParams; };

layout(set = 1, binding = 1) readonly buffer _Lights{

	SLight lights[];
} lightsBuffer;

layout(set = 2, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 2, binding = 1, rgba32f) uniform image2D outputImage;

layout(set = 3, binding = 0) uniform sampler2D wposTex;
layout(set = 3, binding = 1) uniform sampler2D normalTex;

// A wrapper function that encapsulates shooting an ambient occlusion ray query
float shootAmbientOcclusionRay( vec3 orig, vec3 dir, float minT, float maxT )
{
	aoRpl.aoValue = 0.f;

    uint  rayFlags = gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT;

    traceRayEXT(topLevelAS, // acceleration structure
            rayFlags,       // rayFlags
            0xFF,           // cullMask
            0,              // sbtRecordOffset
            0,              // sbtRecordStride
            0,              // missIndex
            orig.xyz,       // ray origin
            minT,           // ray min range
            dir.xyz,         // ray direction
            maxT,           // ray max range
            0      // payload (location = 0)
    );        

	return aoRpl.aoValue;
};

float shadowRayVisibility( vec3 orig, vec3 dir, float minT, float maxT )
{
	shadowRpl.visFactor = 0.f;

    uint  rayFlags = gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT;

    traceRayEXT(topLevelAS, // acceleration structure
            rayFlags,       // rayFlags
            0xFF,           // cullMask
            0,              // sbtRecordOffset
            0,              // sbtRecordStride
            0,              // missIndex
            orig.xyz,       // ray origin
            minT,           // ray min range
            dir.xyz,         // ray direction
            maxT,           // ray max range
            1      // payload (location = 0)
    );        

	return shadowRpl.visFactor;
};

vec3 shootIndirectRay(vec3 orig, vec3 dir, float minT)
{
    indirectRpl.color = vec3(0., 0., 0.);

    uint  rayFlags = gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT;

    traceRayEXT(topLevelAS, // acceleration structure
            rayFlags,       // rayFlags
            0xFF,           // cullMask
            0,              // sbtRecordOffset
            0,              // sbtRecordStride
            0,              // missIndex
            orig.xyz,       // ray origin
            minT,           // ray min range
            dir.xyz,         // ray direction
            1.0e38f,           // ray max range
            2      // payload (location = 0)
    );   

	// Return the color we got from our ray
	return indirectRpl.color;
}

void main() 
{
    const vec2 uv = vec2(gl_LaunchIDEXT.xy)/vec2(gl_LaunchSizeEXT.xy);
    vec4 worldPos = texture(wposTex, uv).rgba;
    vec4 worldNorm = texture(normalTex, uv).rgba;

    SLight sunInfo = lightsBuffer.lights[0];

    vec3 shadeColor = vec3(1., 1., 1.);

    if (worldPos.w != 0.0f)
	{
        //AO
		// Start accumulating from zero if we don't hit the background
        float ambientOcclusion = 0.0f;

        // Initialize a random seed, per-pixel, based on a screen position and temporally varying count
	    uint randSeed = initRand(gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x, aoParams.frameCount);

		for (int i = 0; i < aoParams.numRays; i++)
		{

			// Sample cosine-weighted hemisphere around surface normal to pick a random ray direction
			vec3 worldDir = getCosHemisphereSample(randSeed, worldNorm.xyz);

			// Shoot our ambient occlusion ray and update the value we'll output with the result
			ambientOcclusion += shootAmbientOcclusionRay(worldPos.xyz, worldDir, aoParams.minT, aoParams.aoRadius);
		}

        float aoColor = ambientOcclusion / float(aoParams.numRays); 

        //SHADOW
        float distToLight = length(sunInfo.position.xyz - worldPos.xyz);
        vec3 toLight = -normalize(sunInfo.direction.xyz);
        float shadowMult = shadowRayVisibility(worldPos.xyz, toLight, 0.01, distToLight);

        float NdotL = clamp(dot(worldNorm.xyz, toLight), 0., 1.);

        shadeColor = sunInfo.color.xyz * NdotL * shadowMult * aoColor * M_INV_PI;
        
        //INDIRECT ILLUMINATION
        vec3 bounceDir = getCosHemisphereSample(randSeed, worldNorm.xyz);

        float NdotLIndirect = clamp(dot(worldNorm.xyz, bounceDir), 0., 1.);

        // Shoot our indirect global illumination ray
		vec3 bounceColor = shootIndirectRay(worldPos.xyz, bounceDir, 0.01);

        shadeColor += bounceColor;
	}


    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(shadeColor, 1.0f));
}
