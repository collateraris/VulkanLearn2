#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier:enable
#extension GL_GOOGLE_include_directive : enable

#include "gi_raytrace.h"

layout(location = 0) rayPayloadEXT IndirectRayPayload indirectRpl;
layout(location = 1) rayPayloadEXT AORayPayload aoRpl;

layout(set = 0, binding = 1) uniform sampler2D texSet[];
layout(set = 0, binding = 2) uniform accelerationStructureEXT topLevelAS;

layout(set = 1, binding = 0) uniform _GlobalGIParams { SGlobalGIParams giParams; };

layout(set = 1, binding = 1) readonly buffer _Lights{

	SLight lights[];
} lightsBuffer;

layout(set = 1, binding = 2) readonly buffer ObjectBuffer{

	SObjectData objects[];
} objectBuffer;


layout(set = 2, binding = 0, rgba32f) uniform image2D outputImage;

layout(set = 3, binding = 0) uniform sampler2D wposTex;
layout(set = 3, binding = 1) uniform sampler2D normalTex;
layout(set = 3, binding = 2) uniform sampler2D uvTex;
layout(set = 3, binding = 3) uniform sampler2D objIDTex;
layout(set = 3, binding = 4) uniform samplerCube irradianceMap;
layout(set = 3, binding = 5) uniform samplerCube prefilteredMap;
layout(set = 3, binding = 6) uniform sampler2D   brdfLUT;


#include "gi_raytrace_func.h"

void main() 
{
    const vec2 uv = vec2(gl_LaunchIDEXT.xy)/vec2(gl_LaunchSizeEXT.xy);
    vec4 worldPos = texture(wposTex, uv).rgba;
    vec3 worldNorm = normalize(texture(normalTex, uv).rgb);

    SLight sunInfo = lightsBuffer.lights[0];

    vec3 shadeColor = vec3(0., 0., 0.);

    if (worldPos.w != 0.0f)
	{
        float objIDf = texture(objIDTex, uv).r;
        vec2 gbufferTexCoord = texture(uvTex, uv).rg;   

        // Initialize a random seed, per-pixel, based on a screen position and temporally varying count
	    uint randSeed = initRand(gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x, giParams.frameCount);

        vec3 lightDir = normalize(-sunInfo.direction.xyz);

        DirectInputData inputData;
        inputData.objectId = int(objIDf);
        inputData.texCoord = gbufferTexCoord;
        inputData.worldPos = worldPos.xyz;
        inputData.worldNorm = worldNorm.xyz;

        DirectOutputData outputCurrentData = ggxDirect(inputData, giParams.camPos.xyz, lightDir, sunInfo.color.xyz);
        
        shadeColor = outputCurrentData.Lo;

        const uint INDIRECT_BOUND = 3;
        //INDIRECT ILLUMINATION
        for (int i = 0; i < INDIRECT_BOUND; i++)
        {       
            vec3 viewDir = normalize(giParams.camPos.xyz - worldPos.xyz);
            vec3 H = getGGXMicrofacet(randSeed, outputCurrentData.roughness, outputCurrentData.worldNorm);

            vec3 R = normalize(2.f * dot(viewDir, H) * H - viewDir);

            float  NdotH = clamp(dot(outputCurrentData.worldNorm, H), 0.f, 1.f);
            float  RdotH = clamp(dot(R, H), 0.f, 1.f);

            // What's the probability of sampling vector H from getGGXMicrofacet()?
            float  D = ggxNormalDistribution(NdotH, outputCurrentData.roughness);          // The GGX normal distribution
            float  ggxProb = D * NdotH / (4.f * RdotH);

            IndirectRayPayload indirPayload =  shootIndirectRay(worldPos.xyz, R);

            if (indirPayload.objectId < 0)
            {
                //hit miss
                const float MAX_REFLECTION_LOD = 9;
                vec3 prefilteredColor = textureLod(prefilteredMap, R,  outputCurrentData.roughness * MAX_REFLECTION_LOD).rgb;

                float NdotV = max(dot(outputCurrentData.worldNorm, viewDir), 0.0);

                // ambient lighting (we now use IBL as the ambient term)
                vec3 kS = fresnelSchlickRoughness(NdotV, outputCurrentData.F0, outputCurrentData.roughness);
                vec2 envBRDF  = texture(brdfLUT, vec2(NdotV, outputCurrentData.roughness)).rg;
                vec3 specular = prefilteredColor * (kS * envBRDF.x + envBRDF.y);
                vec3 kD = 1.0 - kS;
                kD *= 1.0 - outputCurrentData.metalness;	  
                vec3 irradiance = texture(irradianceMap, outputCurrentData.worldNorm).rgb;
                vec3 diffuse      = irradiance * outputCurrentData.albedo;
                vec3 ambient = (kD * diffuse + specular);

                shadeColor += ambient;

                break;
            }
            else
            {
                //closest hit
                DirectInputData input2Data;
                input2Data.objectId = indirPayload.objectId;
                input2Data.texCoord = indirPayload.texCoord;
                input2Data.worldPos = indirPayload.worldPos;
                input2Data.worldNorm = indirPayload.worldNorm;

                DirectOutputData outputBoundData = ggxDirect(input2Data, giParams.camPos.xyz, lightDir, sunInfo.color.xyz);

                // Compute some dot products needed for shading
                float  NdotR = clamp(dot(outputCurrentData.worldNorm, R), 0.f, 1.f);
                float  NdotV = clamp(dot(outputCurrentData.worldNorm, viewDir), 0.f, 1.f);

                // Evaluate our BRDF using a microfacet BRDF model
                float  G = IndirectGeometrySmith(outputCurrentData.worldNorm, viewDir, R, outputCurrentData.roughness);   // Use Schlick's masking term approx
                vec3 F = fresnelSchlickRoughness(RdotH, outputCurrentData.F0, outputCurrentData.roughness);  // Use Schlick's approx to Fresnel
                vec3 specular = D * G * F / (4.f * NdotR * NdotV + 0.001); // The Cook-Torrance microfacet BRDF

                vec3 kS = F;
                vec3 kD = 1.0 - kS;
                kD *= 1.0 - outputCurrentData.metalness;

                vec3 irradiance = outputBoundData.Lo;
                vec3 diffuse      = irradiance * outputCurrentData.albedo;
                shadeColor += NdotR * (kD * diffuse + specular) / max(1e-3, ggxProb);

                //for next bound
                worldPos.xyz = indirPayload.worldPos;
                outputCurrentData.worldNorm = outputBoundData.worldNorm;
                outputCurrentData.roughness = outputBoundData.roughness;
                outputCurrentData.metalness = outputBoundData.metalness;
                outputCurrentData.albedo = outputBoundData.albedo;
                outputCurrentData.F0 = outputBoundData.F0;               
            }
        }
	}
    else
    {
        const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
        const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
        vec2 d = inUV * 2.0 - 1.0;

        vec4 target    = giParams.projInverse * vec4(d.x, d.y, 1, 1);
        vec4 direction = giParams.viewInverse * vec4(normalize(target.xyz), 0);
        vec3 dir = normalize(direction.xyz);
        shadeColor = texture(prefilteredMap, dir).rgb;
    }


    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(shadeColor, 1.0f));
}
