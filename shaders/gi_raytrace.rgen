#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier:enable
#extension GL_GOOGLE_include_directive : enable

#include "gi_raytrace.h"

layout(location = 0) rayPayloadEXT IndirectRayPayload indirectRpl;
layout(location = 1) rayPayloadEXT AORayPayload aoRpl;

layout(set = 0, binding = 1) uniform sampler2D texSet[];
layout(set = 0, binding = 2) uniform accelerationStructureEXT topLevelAS;

layout(set = 1, binding = 0) uniform _GlobalGIParams { SGlobalGIParams giParams; };

layout(set = 1, binding = 1) readonly buffer _Lights{

	SLight lights[];
} lightsBuffer;

layout(set = 1, binding = 2) readonly buffer ObjectBuffer{

	SObjectData objects[];
} objectBuffer;


layout(set = 2, binding = 0, rgba32f) uniform image2D outputImage;

layout(set = 3, binding = 0) uniform sampler2D wposTex;
layout(set = 3, binding = 1) uniform sampler2D normalTex;
layout(set = 3, binding = 2) uniform sampler2D uvTex;
layout(set = 3, binding = 3) uniform sampler2D objIDTex;
layout(set = 3, binding = 4) uniform samplerCube irradianceMap;
layout(set = 3, binding = 5) uniform samplerCube prefilteredMap;
layout(set = 3, binding = 6) uniform sampler2D   brdfLUT;


#include "gi_raytrace_func.h"

void main() 
{
    const vec2 uv = vec2(gl_LaunchIDEXT.xy)/vec2(gl_LaunchSizeEXT.xy);
    vec4 worldPos = texture(wposTex, uv).rgba;
    vec3 worldNorm = normalize(texture(normalTex, uv).rgb);

    SLight sunInfo = lightsBuffer.lights[0];

    vec3 shadeColor = vec3(1., 0., 1.);

    if (worldPos.w != 0.0f)
	{
        float objIDf = texture(objIDTex, uv).r;
        uint objID = uint(objIDf);
        SObjectData shadeData = objectBuffer.objects[objID];
        vec2 gbufferTexCoord = texture(uvTex, uv).rg;

        vec3 albedo = texture(texSet[shadeData.diffuseTexIndex], gbufferTexCoord).rgb;

        vec3 emission = vec3(0., 0., 0);
        if (shadeData.emissionTexIndex > 0)
            emission = texture(texSet[shadeData.emissionTexIndex], gbufferTexCoord).rgb;

        float metalness = 0.;
        if (shadeData.metalnessTexIndex > 0)
            metalness = 1. - texture(texSet[shadeData.metalnessTexIndex], gbufferTexCoord).r;    

        float roughness = 1.;
	    if (shadeData.roughnessTexIndex > 0)
		    roughness = texture(texSet[shadeData.roughnessTexIndex], gbufferTexCoord).g; 

        if (shadeData.normalTexIndex > 0)
        {
            mat3 TBN = getTBN(worldNorm);
            vec3 normal = texture(texSet[shadeData.normalTexIndex], gbufferTexCoord).rgb;
            normal = normalize(normal * 2.0 - 1.0);   
            worldNorm = normalize(TBN * normal);
        }  

        shadeColor = emission;   

        // Initialize a random seed, per-pixel, based on a screen position and temporally varying count
	    uint randSeed = initRand(gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x, giParams.frameCount);

        vec3 lightDir = normalize(-sunInfo.direction.xyz);
	    vec3 viewDir = normalize(giParams.camPos.xyz - worldPos.xyz);
        vec3 F0 = vec3(0.04); 
 
        shadeColor += ggxDirect(randSeed, shadeData, gbufferTexCoord, worldPos.xyz, worldNorm.xyz, giParams.camPos.xyz, albedo, roughness, metalness, lightDir, viewDir, sunInfo.color.xyz, F0);

        //AO
        // Start accumulating from zero if we don't hit the background
        float ambientOcclusion = 0.0f;

        for (int i = 0; i < giParams.numRays; i++)
        {
            // Sample cosine-weighted hemisphere around surface normal to pick a random ray direction
            vec3 worldDir = getCosHemisphereSample(randSeed, worldNorm.xyz);

            // Shoot our ambient occlusion ray and update the value we'll output with the result
            ambientOcclusion += shootAmbientOcclusionRay(worldPos.xyz, worldDir, giParams.aoRadius, 0.f);
        }

        float aoColor = ambientOcclusion / float(giParams.numRays);

        vec3 R = reflect(-viewDir, worldNorm);   

        const float MAX_REFLECTION_LOD = 9;
        vec3 prefilteredColor = textureLod(prefilteredMap, R,  roughness * MAX_REFLECTION_LOD).rgb;

        float NdotV = max(dot(worldNorm, viewDir), 0.0);

        // ambient lighting (we now use IBL as the ambient term)
        vec3 kS = fresnelSchlickRoughness(NdotV, F0, roughness);
        vec2 envBRDF  = texture(brdfLUT, vec2(NdotV, roughness)).rg;
        vec3 specular = prefilteredColor * (kS * envBRDF.x + envBRDF.y);
        vec3 kD = 1.0 - kS;
        kD *= 1.0 - metalness;	  
        vec3 irradiance = texture(irradianceMap, worldNorm).rgb;
        vec3 diffuse      = irradiance * albedo;
        vec3 ambient = (kD * diffuse + specular) * aoColor;
        

        shadeColor += ambient;
        //INDIRECT ILLUMINATIO

        //shadeColor += ggxIndirect(randSeed, worldPos.xyz, worldNorm.xyz, giParams.camPos.xyz, albedo, roughness, lightDir, viewDir, F0);
        //shadeColor = vec3(aoColor, aoColor, aoColor);
        //hadeColor = vec3(roughness, roughness, roughness);
	}
    else
    {
        const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
        const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
        vec2 d = inUV * 2.0 - 1.0;

        vec4 target    = giParams.projInverse * vec4(d.x, d.y, 1, 1);
        vec4 direction = giParams.viewInverse * vec4(normalize(target.xyz), 0);
        vec3 dir = normalize(direction.xyz);
        shadeColor = texture(prefilteredMap, dir).rgb;
    }


    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(shadeColor, 1.0f));
}
