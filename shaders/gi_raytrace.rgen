#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable

#include "gi_raytrace.h"

layout(location = 0) rayPayloadEXT AORayPayload aoRpl;
layout(location = 1) rayPayloadEXT ShadowRayPayload shadowRpl;

layout(set = 0, binding = 0) uniform _GlobalAOParams { SGlobalAOParams aoParams; };

layout(set = 0, binding = 1) readonly buffer _Lights{

	SLight lights[];
} lightsBuffer;

layout(set = 1, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 1, binding = 1, rgba32f) uniform image2D outputImage;

layout(set = 2, binding = 0) uniform sampler2D wposTex;
layout(set = 2, binding = 1) uniform sampler2D normalTex;

// A wrapper function that encapsulates shooting an ambient occlusion ray query
float shootAmbientOcclusionRay( vec3 orig, vec3 dir, float minT, float maxT )
{
	aoRpl.aoValue = 0.f;

    uint  rayFlags = gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT;

    traceRayEXT(topLevelAS, // acceleration structure
            rayFlags,       // rayFlags
            0xFF,           // cullMask
            0,              // sbtRecordOffset
            0,              // sbtRecordStride
            0,              // missIndex
            orig.xyz,       // ray origin
            minT,           // ray min range
            dir.xyz,         // ray direction
            maxT,           // ray max range
            0      // payload (location = 0)
    );        

	return aoRpl.aoValue;
};

float shadowRayVisibility( vec3 orig, vec3 dir, float minT, float maxT )
{
	shadowRpl.visFactor = 0.f;

    uint  rayFlags = gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT;

    traceRayEXT(topLevelAS, // acceleration structure
            rayFlags,       // rayFlags
            0xFF,           // cullMask
            0,              // sbtRecordOffset
            0,              // sbtRecordStride
            0,              // missIndex
            orig.xyz,       // ray origin
            minT,           // ray min range
            dir.xyz,         // ray direction
            maxT,           // ray max range
            1      // payload (location = 0)
    );        

	return shadowRpl.visFactor;
};

void main() 
{
    const vec2 uv = vec2(gl_LaunchIDEXT.xy)/vec2(gl_LaunchSizeEXT.xy);
    vec4 worldPos = texture(wposTex, uv).rgba;
    vec4 worldNorm = texture(normalTex, uv).rgba;

    float ambientOcclusion = float(aoParams.numRays);

    SLight sunInfo = lightsBuffer.lights[0];

    float shadowMult = 1;

    if (worldPos.w != 0.0f)
	{
		// Start accumulating from zero if we don't hit the background
		ambientOcclusion = 0.0f;

        // Initialize a random seed, per-pixel, based on a screen position and temporally varying count
	    uint randSeed = initRand(gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x, aoParams.frameCount);

		for (int i = 0; i < aoParams.numRays; i++)
		{

			// Sample cosine-weighted hemisphere around surface normal to pick a random ray direction
			vec3 worldDir = getCosHemisphereSample(randSeed, worldNorm.xyz);

			// Shoot our ambient occlusion ray and update the value we'll output with the result
			ambientOcclusion += shootAmbientOcclusionRay(worldPos.xyz, worldDir, aoParams.minT, aoParams.aoRadius);
		}

        float distToLight = length(sunInfo.position.xyz - worldPos.xyz);
        vec3 toLight = -normalize(sunInfo.direction.xyz);
        shadowMult = shadowRayVisibility(worldPos.xyz, toLight, 0.01, distToLight);
	}

    float aoColor = ambientOcclusion / float(aoParams.numRays); 

    vec3 sunLightColor = sunInfo.color.xyz; 

    sunLightColor *= aoColor;
    sunLightColor *= shadowMult;

    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(sunLightColor, 1.0f));
}
