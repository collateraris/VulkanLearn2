#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable

#include "ao_raytrace.h"

layout(location = 0) rayPayloadEXT AORayPayload aoRpl;


layout(set = 0, binding = 0) uniform _GlobalAOParams { GlobalAOParams aoParams; };

layout(set = 1, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 1, binding = 1, r32f) uniform image2D image;

layout(set = 2, binding = 0) uniform sampler2D wposTex;
layout(set = 2, binding = 1) uniform sampler2D normalTex;

// A wrapper function that encapsulates shooting an ambient occlusion ray query
float shootAmbientOcclusionRay( vec3 orig, vec3 dir, float minT, float maxT )
{
	aoRpl.aoValue = 0.f;

    uint  rayFlags = gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT;

    traceRayEXT(topLevelAS, // acceleration structure
            rayFlags,       // rayFlags
            0xFF,           // cullMask
            0,              // sbtRecordOffset
            0,              // sbtRecordStride
            0,              // missIndex
            orig.xyz,       // ray origin
            minT,           // ray min range
            dir.xyz,         // ray direction
            maxT,           // ray max range
            0      // payload (location = 0)
    );        

	return aoRpl.aoValue;
};

void main() 
{
    const vec2 uv = vec2(gl_LaunchIDEXT.xy)/vec2(gl_LaunchSizeEXT.xy);
    vec4 worldPos = texture(wposTex, uv).rgba;
    vec4 worldNorm = texture(normalTex, uv).rgba;

    float ambientOcclusion = float(aoParams.numRays);

    if (worldPos.w != 0.0f)
	{
		// Start accumulating from zero if we don't hit the background
		ambientOcclusion = 0.0f;

        // Initialize a random seed, per-pixel, based on a screen position and temporally varying count
	    uint randSeed = initRand(gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x, aoParams.frameCount);

		for (int i = 0; i < aoParams.numRays; i++)
		{

			// Sample cosine-weighted hemisphere around surface normal to pick a random ray direction
			vec3 worldDir = getCosHemisphereSample(randSeed, worldNorm.xyz);

			// Shoot our ambient occlusion ray and update the value we'll output with the result
			ambientOcclusion += shootAmbientOcclusionRay(worldPos.xyz, worldDir, aoParams.minT, aoParams.aoRadius);
		}
	}

	float aoColor = ambientOcclusion / float(aoParams.numRays);  

    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(aoColor, aoColor, aoColor, 1.0f));
}
