#version 460

#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_NV_mesh_shader: require

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 42) out;

layout(set = 0, binding = 0) uniform  CameraBuffer{
	mat4 view;
	mat4 proj;
	mat4 viewproj;
} cameraData;

struct ObjectData{
	mat4 model;
};

//all object matrices
layout(std140,set = 1, binding = 0) readonly buffer ObjectBuffer{

	ObjectData objects[];
} objectBuffer;

struct Vertex
{
    vec3 vPosition;
    vec3 vNormal;
    vec2 vTexCoord;
};

layout(binding = 0) readonly buffer Vertices
{
	Vertex vertices[];
};

struct Meshlet
{
	uint vertices[64];
	uint8_t indices[126];
	uint8_t indexCount;
	uint8_t vertexCount;
};

layout(binding = 1) readonly buffer Meshlets
{
	Meshlet meshlets[];
};

layout (location = 0) out vec3 outColor[];
layout (location = 1) out vec2 texCoord[];

void main()
{
	uint mi = gl_WorkGroupID.x;

	for (uint i = 0; i < uint(meshlets[mi].vertexCount); ++i)
	{
		uint vi = meshlets[mi].vertices[i];

		vec3 position = vertices[vi].vPosition;
		vec3 normal = vertices[vi].vNormal;
		vec2 texcoord = vertices[vi].vTexCoord;

        mat4 modelMatrix = objectBuffer.objects[mi].model;
        mat4 transformMatrix = (cameraData.viewproj * modelMatrix);
		gl_MeshVerticesNV[i].gl_Position = transformMatrix * vec4(position, 1.0f);
		outColor[i] = vec3(normal * 0.5 + vec3(0.5));
        texCoord[i] = texcoord;
	}

    gl_PrimitiveCountNV = uint(meshlets[mi].indexCount) / 3;

	for (uint i = 0; i < uint(meshlets[mi].indexCount); ++i)
	{
		// TODO: possibly bad for perf, consider writePackedPrimitiveIndices4x8NV
		gl_PrimitiveIndicesNV[i] = uint(meshlets[mi].indices[i]);
	}
}

