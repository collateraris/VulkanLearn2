#version 460

#extension GL_NV_mesh_shader : require

layout(local_size_x = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 42) out;

layout(set = 0, binding = 0) uniform  CameraBuffer{
	mat4 view;
	mat4 proj;
	mat4 viewproj;
} camData;

struct s_vertex
{
	vec3 position;
	vec3 normal;
	vec2 uv;
};

layout (std430, set = 1, binding = 0) buffer _vertices
{
	s_vertex vertices[];
} vb;

struct s_meshlet
{
	uint vertices[64];
	uint indices[126];
	uint vertex_count;
	uint index_count;
};

layout (std430, set = 1, binding = 1) buffer _meshlets
{
	s_meshlet meshlets[];
} mbuf;

// Custom vertex output block
layout (location = 0) out PerVertexData
{
  vec4 color;
} v_out[];   // [max_vertices]

float scale = 0.95;
const vec3 colors[3] = {vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), vec3(0.0,0.0,1.0)};
const vec3 vertices[3] = {vec3(-1,-1,0), vec3(0,1,0), vec3(1,-1,0)};

void main()
{
  uint mi = gl_WorkGroupID.x; 

  int pos1 = int(vb.vertices[1].position.x);
  
  if (pos1 == 0){

  vec4 pos = vec4(vb.vertices[0].position * scale, 1.0);
  // GL->VK conventions...
  pos.y = -pos.y; pos.z = (pos.z + pos.w) / 2.0;
  gl_MeshVerticesNV[0].gl_Position = pos; 

  pos = vec4(vb.vertices[1].position * scale, 1.0);
  pos.y = -pos.y; pos.z = (pos.z + pos.w) / 2.0;
  gl_MeshVerticesNV[1].gl_Position = pos; 

  pos = vec4(vb.vertices[2].position * scale, 1.0);
  pos.y = -pos.y; pos.z = (pos.z + pos.w) / 2.0;
  gl_MeshVerticesNV[2].gl_Position = pos; 


  v_out[0].color = vec4(colors[0], 1.0);
  v_out[1].color = vec4(colors[1], 1.0);
  v_out[2].color = vec4(colors[2], 1.0);


  gl_PrimitiveIndicesNV[0] = 0;
  gl_PrimitiveIndicesNV[1] = 1;
  gl_PrimitiveIndicesNV[2] = 2;

  gl_PrimitiveCountNV = 1;
  }
}